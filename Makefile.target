# -*- Mode: makefile -*-

include ../config-host.mak
include config-target.mak
include config-devices.mak
include $(SRC_PATH)/rules.mak

include $(SRC_PATH)/dbaf/config.replay

$(call set-vpath, $(SRC_PATH))
ifdef CONFIG_LINUX
QEMU_CFLAGS += -I../linux-headers $(RR_CFLAGS)
endif
QEMU_CFLAGS += -I.. -I$(SRC_PATH)/target-$(TARGET_BASE_ARCH) -DNEED_CPU_H $(RR_CFLAGS)

QEMU_CFLAGS+=-I$(SRC_PATH)/include

ifdef CONFIG_USER_ONLY
# user emulator name
QEMU_PROG=qemu-$(TARGET_NAME)
QEMU_PROG_BUILD = $(QEMU_PROG)
else
# system emulator name
QEMU_PROG=qemu-system-$(TARGET_NAME)$(EXESUF)
ifneq (,$(findstring -mwindows,$(libs_softmmu)))
# Terminate program name with a 'w' because the linker builds a windows executable.
QEMU_PROGW=qemu-system-$(TARGET_NAME)w$(EXESUF)
$(QEMU_PROG): $(QEMU_PROGW)
	$(call quiet-command,$(OBJCOPY) --subsystem console $(QEMU_PROGW) $(QEMU_PROG),"  GEN   $(TARGET_DIR)$(QEMU_PROG)")
QEMU_PROG_BUILD = $(QEMU_PROGW)
else
QEMU_PROG_BUILD = $(QEMU_PROG)
endif
endif

PROGS=$(QEMU_PROG) $(QEMU_PROGW)
STPFILES=

config-target.h: config-target.h-timestamp
config-target.h-timestamp: config-target.mak

ifdef CONFIG_TRACE_SYSTEMTAP
stap: $(QEMU_PROG).stp-installed $(QEMU_PROG).stp

ifdef CONFIG_USER_ONLY
TARGET_TYPE=user
else
TARGET_TYPE=system
endif

$(QEMU_PROG).stp-installed: $(SRC_PATH)/trace-events
	$(call quiet-command,$(TRACETOOL) \
		--format=stap \
		--backend=$(TRACE_BACKEND) \
		--binary=$(bindir)/$(QEMU_PROG) \
		--target-name=$(TARGET_NAME) \
		--target-type=$(TARGET_TYPE) \
		< $< > $@,"  GEN   $(TARGET_DIR)$(QEMU_PROG).stp-installed")

$(QEMU_PROG).stp: $(SRC_PATH)/trace-events
	$(call quiet-command,$(TRACETOOL) \
		--format=stap \
		--backend=$(TRACE_BACKEND) \
		--binary=$(realpath .)/$(QEMU_PROG) \
		--target-name=$(TARGET_NAME) \
		--target-type=$(TARGET_TYPE) \
		< $< > $@,"  GEN   $(TARGET_DIR)$(QEMU_PROG).stp")

else
stap:
endif

all: $(PROGS) stap

# Dummy command so that make thinks it has done something
	@true

#########################################################
# cpu emulator library
tcg/tcg-llvm.o: QEMU_CXXFLAGS+=$(LLVM_CXXFLAGS)
obj-y = exec.o translate-all.o cpu-exec.o
obj-y += tcg/tcg.o tcg/optimize.o
obj-$(CONFIG_TCG_INTERPRETER) += tci.o
obj-$(CONFIG_TCG_INTERPRETER) += disas/tci.o
obj-y += fpu/softfloat.o
obj-y += target-$(TARGET_BASE_ARCH)/
obj-y += disas.o
obj-$(call notempty,$(TARGET_XML_FILES)) += gdbstub-xml.o
obj-$(call lnot,$(CONFIG_KVM)) += kvm-stub.o
obj-$(CONFIG_LLVM) += tcg/tcg-llvm.o
#DBAF make this complie in target dir,so that we can add some config info
obj-y += vl.o
vl.o-cflags := $(GPROF_CFLAGS) $(SDL_CFLAGS)
#########################################################
# Linux user emulator target

ifdef CONFIG_LINUX_USER

QEMU_CFLAGS+=-I$(SRC_PATH)/linux-user/$(TARGET_ABI_DIR) -I$(SRC_PATH)/linux-user

obj-y += linux-user/
obj-y += gdbstub.o thunk.o user-exec.o

endif #CONFIG_LINUX_USER

#########################################################
# BSD user emulator target

ifdef CONFIG_BSD_USER

QEMU_CFLAGS+=-I$(SRC_PATH)/bsd-user -I$(SRC_PATH)/bsd-user/$(TARGET_ABI_DIR)

obj-y += bsd-user/
obj-y += gdbstub.o user-exec.o

endif #CONFIG_BSD_USER

#########################################################
# System emulator target
ifdef CONFIG_SOFTMMU
obj-y += arch_init.o cpus.o monitor.o gdbstub.o balloon.o ioport.o
obj-y += qtest.o
obj-y += hw/
obj-$(CONFIG_FDT) += device_tree.o
obj-$(CONFIG_KVM) += kvm-all.o
obj-y += memory.o savevm.o cputlb.o
obj-y += memory_mapping.o
obj-y += dump.o
obj-y += rr_log.o
LIBS+=$(libs_softmmu)

# xen support
obj-$(CONFIG_XEN) += xen-common.o
obj-$(CONFIG_XEN_I386) += xen-hvm.o xen-mapcache.o
obj-$(call lnot,$(CONFIG_XEN)) += xen-common-stub.o
obj-$(call lnot,$(CONFIG_XEN_I386)) += xen-hvm-stub.o

# Hardware support
ifeq ($(TARGET_NAME), sparc64)
obj-y += hw/sparc64/
else
obj-y += hw/$(TARGET_BASE_ARCH)/
endif

GENERATED_HEADERS += hmp-commands.h qmp-commands-old.h

endif # CONFIG_SOFTMMU

# Workaround for http://gcc.gnu.org/PR55489, see configure.
%/translate.o: QEMU_CFLAGS += $(TRANSLATE_OPT_CFLAGS)

dummy := $(call unnest-vars,,obj-y)
all-obj-y := $(obj-y)

block-obj-y :=
common-obj-y :=
include $(SRC_PATH)/Makefile.objs
dummy := $(call unnest-vars,.., \
               block-obj-y \
               block-obj-m \
               common-obj-y \
               common-obj-m)
               
ifdef CONFIG_LLVM

#########################################################
# LLVM library

# regular bitcode
llvm-y =

# morphed bitcode - morph call instructions and function names after bitcode is
# linked together to make helper bitcode available for use by plugins
llvmmorph-y =

ifeq ($(TARGET_BASE_ARCH), i386)
llvm-y += target-i386/cc_helper.bc2 target-i386/excp_helper.bc2 target-i386/fpu_helper.bc2
llvm-y += target-i386/int_helper.bc2 target-i386/mem_helper.bc2 target-i386/misc_helper.bc2 
llvm-y += target-i386/seg_helper.bc2 target-i386/smm_helper.bc2 target-i386/svm_helper.bc2 
llvm-y += target-i386/helper.bc2
llvm-y += util/host-utils.bc2 fpu/softfloat.bc2
llvmmorph-y += llvm-helpers.bc
endif

$(llvm-y): %.bc2: %.c $(GENERATED_HEADERS)

llvm-helpers.bc1: $(llvm-y)
	$(call quiet-command,$(LLVM_LINK) -o $@ $^,"  LLVM_LINK    $(TARGET_DIR)$@")

$(llvmmorph-y): %.bc: %.bc1

# add this to the all target, and make sure to run the code morph at the end of building
all: $(llvmmorph-y)

endif # CONFIG_LLVM
               
#########################################################
# DBAF library
dbafobj-y :=
ifdef CONFIG_DBAF
$(call set-vpath, $(SRC_PATH))
dbafobj-y += dbaf/signals/signals.o 
dbafobj-y += dbaf/utils/Output.o
dbafobj-y += dbaf/utils/disasplus.o
dbafobj-y += dbaf/utils/HashtableWrapper.o
dbafobj-y += dbaf/Synchronization.o
dbafobj-y += dbaf/DBAF.o dbaf/DBAFExecutionState.o dbaf/Plugin.o
dbafobj-y += dbaf/plugins/CorePlugin.o
dbafobj-y += dbaf/Annotation.o
dbafobj-y += dbaf/ConfigFile.o 
dbafobj-y += dbaf/plugins/SignalTesterPlugin.o
dbafobj-y += dbaf/DBAF_main.o
dbafobj-y += dbaf/DBAF_qemu_memory.o
dbafobj-y += dbaf/llvm/helper_call_morph.o
#dbafobj-y += dbaf/rr_log.o
dbafobj-y += dbaf/plugins/OSMonitor.o dbaf/plugins/OShelper/function_map.o dbaf/plugins/WindowsMonitor.o 
dbafobj-y += dbaf/plugins/X86FunctionMonitor.o dbaf/plugins/ModuleExecutionDetector.o dbaf/plugins/X86HookManager.o

vl.o: QEMU_CFLAGS+=-Wno-array-bounds

dbaf/ConfigFile.o: QEMU_CXXFLAGS+=-fno-inline

dbaf/llvm/helper_call_morph.o: QEMU_CXXFLAGS+=$(LLVM_CXXFLAGS)

libdbaf.a: $(dbafobj-y)

$(dbafobj-y): QEMU_CXXFLAGS+=$(DBAF_CXXFLAGS)

endif
all-obj-y += $(dbafobj-y) $(common-obj-y)
all-obj-$(CONFIG_SOFTMMU) += $(block-obj-y)

ifndef CONFIG_HAIKU
LIBS+=-lm
endif

# build either PROG or PROGW
$(QEMU_PROG_BUILD): $(all-obj-y) libdbaf.a ../libqemuutil.a ../libqemustub.a
	$(call LINK,$^)

gdbstub-xml.c: $(TARGET_XML_FILES) $(SRC_PATH)/scripts/feature_to_c.sh
	$(call quiet-command,rm -f $@ && $(SHELL) $(SRC_PATH)/scripts/feature_to_c.sh $@ $(TARGET_XML_FILES),"  GEN   $(TARGET_DIR)$@")

hmp-commands.h: $(SRC_PATH)/hmp-commands.hx
	$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,"  GEN   $(TARGET_DIR)$@")

qmp-commands-old.h: $(SRC_PATH)/qmp-commands.hx
	$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,"  GEN   $(TARGET_DIR)$@")

clean:
	rm -f *.a *~ $(PROGS)
	rm -f $(shell find . -name '*.[od]')
	rm -f hmp-commands.h qmp-commands-old.h gdbstub-xml.c
ifdef CONFIG_DBAF
	if [ -d dbaf ]; then find dbaf -name \*.o -exec rm {} \; ; fi
	if [ -d dbaf ]; then find dbaf -name \*.d -exec rm {} \; ; fi
endif
ifdef CONFIG_TRACE_SYSTEMTAP
	rm -f *.stp
endif

install: all
ifneq ($(PROGS),)
	$(INSTALL_PROG) $(PROGS) "$(DESTDIR)$(bindir)"
ifneq ($(STRIP),)
	$(STRIP) $(PROGS:%="$(DESTDIR)$(bindir)/%")
endif
endif
ifdef CONFIG_TRACE_SYSTEMTAP
	$(INSTALL_DIR) "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset"
	$(INSTALL_DATA) $(QEMU_PROG).stp-installed "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset/$(QEMU_PROG).stp"
endif

GENERATED_HEADERS += config-target.h
Makefile: $(GENERATED_HEADERS)
